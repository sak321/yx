import json, urllib.request, socket, re

          final_list = []
          ip_pattern = re.compile(r'^(?:[0-9]{1,3}\.){3}[0-9]{1,3}$')

          def get_country(target):
              try:
                  host = target.split(':')[0]
                  query_ip = socket.gethostbyname(host)
                  with urllib.request.urlopen(f'http://ip-api.com/json/{query_ip}?fields=countryCode', timeout=3) as resp:
                      return json.loads(resp.read().decode()).get('countryCode', 'UN')
              except:
                  return 'XX'

          # --- 1. 处理域名接口 (cfIpTop20) ---
          try:
              with open('data_domain.json', 'r') as f:
                  d = json.load(f)
                  items = d.get('data', {}).get('good', [])
                  # 针对移动排序：ydScore
                  items.sort(key=lambda x: x.get('ydScore', 999))
                  for idx, item in enumerate(items[:2], 1):
                      domain = item.get('ip')
                      country = get_country(domain)
                      final_list.append(f"{domain}# {country}+域名优选{idx}")
          except: pass

          # --- 2. 处理纯 IP 接口 (cfIpApi) ---
          try:
              with open('data_ip.json', 'r') as f:
                  d = json.load(f)
                  raw_data = d.get('data', {})
                  
                  all_raw_ips = []
                  # 合并所有分类中的 IP 项
                  for cat in ['CM', 'CT', 'CU', 'AllAvg']:
                      all_raw_ips.extend(raw_data.get(cat, []))

                  # 核心优选逻辑：
                  # 1. 必须是纯 IP 格式
                  # 2. 针对移动优化：按 ydPkgLostRateAvg (丢包) 第一优先，ydLatencyAvg (延迟) 第二优先
                  # 3. 过滤掉重复 IP
                  seen = set()
                  # 先过滤掉域名，只留 IP，并确保丢包率尽量低
                  valid_ips = []
                  for i in all_raw_ips:
                      ip = i.get('ip')
                      if ip and ip_pattern.match(ip) and ip not in seen:
                          seen.add(ip)
                          valid_ips.append(i)

                  # 按照移动指标排序：先排丢包，再排延迟
                  valid_ips.sort(key=lambda x: (x.get('ydPkgLostRateAvg', 100), x.get('ydLatencyAvg', 999)))

                  # 补充到总数 16 个
                  needed = 16 - len(final_list)
                  for idx, item in enumerate(valid_ips[:needed], 1):
                      ip = item.get('ip')
                      country = get_country(ip)
                      final_list.append(f"{ip}:443#lyz_{country}_优选{idx}")
          except: pass

          # --- 3. 写入文件 ---
          with open('ip.txt', 'w') as f:
              f.write('\n'.join(final_list))
